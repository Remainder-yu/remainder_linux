谨记：
带着问题学习，为什么引入概念及工具？解决了哪些问题？哪些场景会需要？带来了哪些额外的工作量？
将章节知识抽象化，系统框架为整体，到具体技术细节，解决实现具体方式，对应作用。

## 链接器介绍

### 什么是链接器？
链接指的是把包含代码段、数据段、符号表的目标文件按照对应的段的内容收集起来按照某种格式（例如ELF格式）组合成一个可执行二进制文件的过程。而链接器用于完成上述链接过程。在操作系统发展的早期并没有链接器的概念，操作系统的加载器（Loader，LD）做了以上工作，由于技术发展操作系统复杂性，慢慢出现链接器，所以LD成为链接器的代名词。


在操作系统实现中常常需要编写一个链接脚本来描述最终可执行文件的代码段、数据段布局。
### 链接器的使用
```shell
$(ARMGNU)-ld -T $(SRC_DIR)/linker.ld  -Map benos.map -o $(BUILD_DIR)/benos.elf  $(OBJ_FILES)
# 例如：
aarch64-linux-gnu-ld -T src/linker.ld  -Map benos.map -o build/benos.elf  build/printkc.o build/irq_c.o build/string_c.o  
```

### 链接脚本

### 重定位

核心概念：
* 加载地址：存储代码的物理地址，在GNU链接脚本里成为LMA。
* 运行地址：程序运行时的地址，在GNU链接脚本里称为VMA
* 链接地址：在编译链接时指定的地址，编程人员设想将来程序运行的地址。objdump工具反汇编，查看的就是链接地址。


## 核心问题

### 为什么要刻意设置加载地址、运行地址以及链接地址不一样呢？


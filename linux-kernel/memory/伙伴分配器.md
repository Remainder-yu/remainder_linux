# 1. 伙伴分配器

```shell
# A1平台
root@a1one:~# cat /proc/buddyinfo
Node 0, zone      DMA      3      2      2      1      4      2      3      2      3      3    332
Node 0, zone   Normal    100    462    550    288     98     48     25     14      5      3   6271

root@a1one:~# cat /proc/pagetypeinfo
Page block order: 9
Pages per block:  512

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone      DMA, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone      DMA, type      Movable      3      2      2      1      4      2      3      2      3      3    268
Node    0, zone      DMA, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone      DMA, type          CMA      0      0      0      0      0      0      0      0      0      0     64
Node    0, zone      DMA, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone      DMA, type      Isolate      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type    Unmovable     83     70     24     24     36     12      2      1      1      2      0
Node    0, zone   Normal, type      Movable    982    383    238     75     11      1      1      0      0      0   1809
Node    0, zone   Normal, type  Reclaimable      2      1      9     58     13      6      1      1      1      0      0
Node    0, zone   Normal, type          CMA     15     40    109     75     40     29     21     12      3      1   4462
Node    0, zone   Normal, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Number of blocks type     Unmovable      Movable  Reclaimable          CMA   HighAtomic      Isolate
Node 0, zone      DMA            2         1918            0          128            0            0
Node 0, zone   Normal           56         5306           30         8944            0            0
root@a1one:~#

# 每个分区下面，不同类型链表大小
```

内核初始化完毕后，使用页分配器管理物理页，当前使用的页分配器是伙伴分配器，伙伴分配器特点是算法简单且效率高。

## 1.1. 伙伴系统的结构
系统内存的每个物理内存页都对应一个struct page，每个内存域都管理一个struct zone。

## 1.2. 伙伴算法

### 1.2.1. 算法设计原理

每个zone区域对应一个伙伴系统管理。
系统在进行初始启动时。对所有的物理页面来说，都是首先把大的空闲内存块链接到较大的空闲链表中，然后再挂在较小的链表中。
对于伙伴算法来说，伙伴是由满足以下定义的两个块组成：
（1）两个块的大小相同
（2）两个块的物理地址连续
（3）两个块是从一个大块中分离出来的
伙伴算法在进行内存分配和回收时，把满足上面三个条件的两个块合并为一个大块，如果合并后的块还满足条件，那么继续合并，直到最大值。

### 1.2.2. Buddy算法的数据结构

Linux系统提供了对非一致内存访问模型的支持。
对于内存节点和pg_data_t的描述符是一一对应的关系，系统中内存节点和pg_data_t的描述符在数量上是一样的。节点描述符组成了内存节点单链表，他们用指针串联在一起，并由pgdat_list变量指向作为其第一个元素。
同时，每个节点的物理内存被划分为四个管理区Zone。每个管理区拥有自己的一个伙伴系统，通过伙伴系统来管理自己的物理内存。每个物理内存又被划分为若干个物理页面，并且这些物理页面大小相等，使用page描述符描述物理页面，所有物理页面组成一个page描述符组mem_map.

对于不同管理区，这种算法使用单独伙伴算法管理。在每一种类中，不同的页框都由一个free_area_struct结构体进行管理。系统将10个free_area_struct结构体组成一个free_area[]数组。

```cpp
struct zone {
	/* Read-mostly fields */

	/* zone watermarks, access with *_wmark_pages(zone) macros */
	unsigned long _watermark[NR_WMARK];
	unsigned long watermark_boost;

	unsigned long nr_reserved_highatomic;

	/*
	 * We don't know if the memory that we're going to allocate will be
	 * freeable or/and it will be released eventually, so to avoid totally
	 * wasting several GB of ram we must reserve some of the lower zone
	 * memory (otherwise we risk to run OOM on the lower zones despite
	 * there being tons of freeable ram on the higher zones).  This array is
	 * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl
	 * changes.
	 */
	long lowmem_reserve[MAX_NR_ZONES];
    	/* free areas of different sizes */
	struct free_area	free_area[MAX_ORDER];
    ......
}

typedef struct pglist_data {
	/*
	 * node_zones contains just the zones for THIS node. Not all of the
	 * zones may be populated, but it is the full list. It is referenced by
	 * this node's node_zonelists as well as other node's node_zonelists.
	 */
	struct zone node_zones[MAX_NR_ZONES];

	/*
	 * node_zonelists contains references to all zones in all nodes.
	 * Generally the first zones will be references to this node's
	 * node_zones.
	 */
	struct zonelist node_zonelists[MAX_ZONELISTS];
}

struct free_area {
    // 不是链表的节点，将物理页划分为不同的类型
	struct list_head	free_list[MIGRATE_TYPES];
	unsigned long		nr_free;
};

enum migratetype {
	MIGRATE_UNMOVABLE,
	MIGRATE_MOVABLE,
	MIGRATE_RECLAIMABLE,
	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
#ifdef CONFIG_CMA
	/*
	 * MIGRATE_CMA migration type is designed to mimic the way
	 * ZONE_MOVABLE works.  Only movable pages can be allocated
	 * from MIGRATE_CMA pageblocks and page allocator never
	 * implicitly change migration type of MIGRATE_CMA pageblock.
	 *
	 * The way to use it is to change migratetype of a range of
	 * pageblocks to MIGRATE_CMA which can be done by
	 * __free_pageblock_cma() function.  What is important though
	 * is that a range of pageblocks must be aligned to
	 * MAX_ORDER_NR_PAGES should biggest page be bigger than
	 * a single pageblock.
	 */
	MIGRATE_CMA,
#endif
#ifdef CONFIG_MEMORY_ISOLATION
	MIGRATE_ISOLATE,	/* can't allocate from here */
#endif
	MIGRATE_TYPES
};

```



可以通过全局变量获取page组成的数组的指针mem_map指针。


### 1.2.3. Buddy算法物理页面分配


#### 1.2.3.1. 建立地址映射

内核需要物理内存时，很多情况是整页分配的，这在上面的mem_map中摘一个page下来。内核捕获缺页异常，然后分配一个page以建立映射。

内核代码所访问的地址都是虚拟地址，因为CPU指令接收的就是虚拟地址。但是建立地址映射，内核的页表里面填写的却是物理地址，因为地址映射的目标就是要得到物理地址。mem_map中的page就是根据物理内存来建立的，每一个page就对应一个物理页。
由于内核空间的页表项是写死的


### 1.2.4. 外碎片--空洞
解决碎片化问题--在伙伴系统中引入了迁移类型

在内存中有固定位置，不能随意移动，比如内核分配的内存。  
每个进程对应一个task结构，它指向一个mm结构，这就是该进程的内存管理器。对于线程来说，每个线程也都有一个task结构，但是他们都指向同一个mm，所以地址空间是共享的。

mm->pgd指向容纳页表的内存，每个进程都有自己的mm，每个mm有自己的页表。于是，进程调度时，页表被切换，一般会有一个CPU寄存器来保存页表的地址，比如说AMRv8下的TTRBx，页表切换就是改变寄存器的值。
所以各个进程的地址空间互不影响，因为页表都不一样了，当然无法访问到别人的地址空间上。

用户程序对内存的操作都是对MM的操作，具体来说是对mm上的VMA（虚拟内存空间）的操作。这些VMA代表进程空间的各个区域，比如堆、栈、代码区、数据区、各种映射区等。
用户程序对内存的操作并不会直接影响到页表，更不会直接影响到物理内存的分配。比如malloc成功，仅仅是改变了某个vm
，页表不会变，物理内存的分配也不会变。
假设用户分配了内存，然后访问这块内存。由于页表里面没有记录相关的映射，CPU产生一次缺页异常。内核捕获异常，检查产生的异常的地址是不是存在于一个合法的vm
中。如果不是，则给进程一个段错误，让其崩溃；如果是，则分配一个物理页，并为之建立映射。

# setup_arch简介-内存管理初始化

linux内存管理主要分成三个阶段：
1. MMU未打开时，还在汇编时代时。
2. fixmap、memblock时代，此时伙伴系统还未成形，一直到mem_init函数中的mem_init将空闲内存加载到zone中
3. 伙伴系统建立

## start_kernel

后续分析：start_kernel主要流程，其中和内存管理相关的系统初始化函数及原理。

引导程序负责加载内核映像文件并将控制权交给内核，从而启动操作系统。在x86架构下，引导程序通过设置中断向量表使CPU执行到内核的入口地址，从而调用start_kernel函数。
具体调用start_kernel函数的步骤如下：

1. 引导程序加载内核映像文件到内存中，一般是将内核映像文件加载到指定的物理内存地址。
2. 引导程序设置CPU的寄存器，包括设置CS（Code Segment）寄存器为内核的代码段选择子，设置EIP（Instruction Pointer）寄存器为内核的入口地址，也就是start_kernel函数的地址。
3. 引导程序发送中断指令（例如，int指令），触发中断异常。
4. CPU接收到中断异常后，根据中断向量表处理该中断。在引导程序设置的中断向量表中，将指定的中断向量与内核入口地址关联起来。
5. CPU根据中断向量表找到与该中断向量关联的内核入口地址，将CPU的控制权转移至该地址，即开始执行start_kernel函数。
需要注意的是，具体的实现会因不同的引导程序而有所差异。例如，GRUB引导程序使用Multiboot规范加载内核，并通过设置CPU的寄存器和中断向量表来调用start_kernel函数。而UEFI引导程序则有自己的加载方式和调用机制。因此，具体的调用过程会根据引导程序的不同而有所差异。

### bootmem
在Linux内核启动的早期阶段，物理内存的管理非常重要。在这个阶段，内核需要确定可用的物理内存范围，并为各种数据结构和功能分配内存空间。为了完成这些任务，Linux内核提供了bootmem分配器。
bootmem分配器是一种在内核启动期间使用的简单、高效的内存管理方式。它的目标是在内核启动早期，预留一段连续的物理内存，作为内核的运行空间，并为内核数据结构和功能分配内存。
具体来说，bootmem分配器的主要作用有以下几点：


1. 管理物理内存的分配和释放：bootmem分配器可以将物理内存划分为多个区域，并跟踪每个区域的可用和已分配状态。当内核需要分配内存时，bootmem分配器会检查可用内存并分配一块连续的内存区域。
2. 提供用于内核数据结构和功能的内存空间：在内核启动早期，许多重要的数据结构和功能需要预分配内存。例如，内核必须分配存储页表的内存、内核堆栈的内存、内核模块的内存等等。bootmem分配器可以在这个阶段为这些数据结构和功能提供必要的内存。
3. 支持动态内存分配器：bootmem分配器可以在内核启动阶段启用一个简单的动态内存分配器，提供基本的内存分配和释放功能。这样，在内核运行到后续阶段时，可以使用更复杂的内存分配器来管理内存。
需要注意的是，bootmem分配器只在内核启动阶段使用，并且在系统初始化完成后就不再起作用。后续的内存管理任务会由更高级的分配器（例如，SLAB分配器和SLUB分配器）接管，提供更灵活和高级的内存管理功能。


## setup_arch
在韦东山qemu_sdk中，是从 `arch/arm/kernel/setup.c`文件的 `void __init setup_arch(char **cmdline_p)`函数接口开始的。



参考：
[博客文章](https://blog.csdn.net/u012489236/category_9614673.html)



###  linux怎么启动start_kernel函数的？
linux启动的主要流程：
1. 上电和硬件初始化：当电源接通时，计算机硬件 开始进程初始化和自检操作。这包括处理 器的启动、内存 的初始化、设备控制器的初始化等。
2. 引导加载程序的执行（bootloader）：计算机硬件初始化完成后，引导加载程序加载到 内存中执行。引导加载程序的功能是加载并 启动操作系统内核。通过 读取引导配置文件、分区表 等信息，确定要加载 的内核镜像的位置和参数。
3. 内核的加载和执行：引导程序根据配置加载内核镜像到内存中，并将 控制权交给内核的入口点。 内核的入口点事内核的启动 函数`start_kernel()`。内核所在的内存位置和启动参数由引导加载程序传递给内核。
4. start_kernel()函数的执行：start_kernel()函数是Linux内核的入口点。在这个函数中，内核进行各种初始化操作，如设置内核的运行环境、初始化调度器、创建第一个进程、初始化内存管理、设备驱动、文件系统、网络等子系统。
5. 初始化和启动子系统：在start_kernel()函数中，依次初始化和启动各个子系统。这包括进程管理、内存管理、文件系统、网络等。每个子系统都有相应的初始化函数和数据结构被调用和设置。
6. 运行内核主循环：当所有子系统初始化完成后，内核进入主循环，等待和处理各种事件。这些事件包括硬件中断、软中断、系统调用等。内核根据事件的类型和优先级进行相应的处理。
7. 用户空间初始化：最后，内核会启动用户空间初始化进程（如init进程），开始用户空间的初始化和启动用户应用程序。

linux内核使用伙伴系统管理内存，那么在伙伴系统工作 前，如何管理内存？memblock。

### dtb文件
设备树二进制文件。是一种描述硬件平台和设备的数据结构，它以一种独立于硬件和操作系统的方式描述了设备的特性、寄存器地址、中断信息等。
目的：操作系统可以使用通用的设备树描述来适配和管理各种硬件设备，而无需依赖硬件具体细节。
设备树本身是一种以文本方式描述的数据结构，一般采用后缀名为 .dts 的文件进行存储和编写。
然而，为了提高解析和使用上的效率，设备树还可以被编译成二进制格式，即 DTB 文件。DTB 文件是设备树源文件编译后的结果，其中包含了设备树的完整描述信息，并用于在 Linux 内核中进行设备的识别、驱动加载和硬件配置等操作。

在 Linux 中，当系统启动时，Bootloader 会负责加载 DTB 文件并将其传递给内核。内核会解析 DTB 文件中的描述信息，以识别系统中的各种设备并执行相应的初始化操作。

DTS 文件是设备树的源文件，采用文本格式进行编写，通常使用后缀名为 .dts 的文件进行存储。DTS 文件中包含了设备树的描述信息，包括设备节点、设备属性、中断控制器信息、寄存器描述等。通过编辑和修改 DTS 文件，可以修改设备树的描述信息，从而对硬件设备进行配置、适配和调试。
在 Linux 内核编译过程中，DTS 文件会被使用工具（如 dtc 等）编译成设备树二进制文件（DTB），以便在系统启动时传递给内核。内核通过解析 DTB 文件中的描述信息，对硬件设备进行识别和适配，并加载相应的驱动进行初始化操作。

### 系统是怎么知道物理内存的？
[物理内存的初始化](https://www.cnblogs.com/LoyenWang/p/11440957.html)
在内存管理真正初始化之前，内核的代码执行需要 分配该如何处理？

Uboot会将kernel image和dtb拷贝到内存中，并且将dtb物理地址告知kernel，kernel需要从该物理地址上读到dtb文件并解析，才能得到最终的内存信息，dtb的物理地址需要映射到虚拟地址上才能访问。
但是这个时候paging_init还没有 调用 ，物理地址的映射都没有完成，该怎么办呢？
>Fixed map 机制出现了。
当所有内存添加到系统之后，在mm_init之前，系统 会使用memblock模块来对内存进行管理。

### early_fixmap_init

简单来说，Fixed map指的是虚拟地址中的一段区域，在该区域中所有的线性地址是在编译阶段就确定好的，这些虚拟地址需要在boot阶段去映射到物理地址上。
虚拟地址空间图：
专门的Fixed区域，


# 学习方法
参考资料：
该博客示意图较多，逻辑清晰：
[内存管理](https://www.cnblogs.com/LoyenWang/tag/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)
结合Vnote两个笔记本：内存管理和LLD，可以好好分析主要流程及源码 数据结构和逻辑。其中涉及的算法等。
参考哔站培训视频红黑树及内存管理，学习完成内存管理模块。


#  i.MX 6ULL单核处理器，配备Arm® Cortex®-A7内核

采用单个Arm Cortex-A7内核，运行速度高达528 MHz。i.MX 6ULL应用处理器包括一个集成的电源管理模块，降低了外接电源的复杂性，并简化了上电时序。这个系列的每个处理器提供多种存储器接口，其中包括16位LPDDR2、DDR3、DDR3L、原始和管理的NAND闪存、NOR闪存、eMMC、Quad SPI和各种其他接口，用于连接外围设备，如WLAN、Bluetooth®、GPS、显示器和摄像头传感器。

Cortex-A7处理器是一种由Arm公司推出的基于Armv7-A架构的高能耗处理器。

Cortex-A7内核，运行频率900 MHz，128 KB L2缓存。

https://www.nxp.com.cn/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors/i-mx-6ull-single-core-processor-with-arm-cortex-a7-core:i.MX6ULL#:~:text=i.MX%206ULL%E6%98%AF%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8A%9F%E6%95%88%E3%80%81%E9%AB%98%E6%80%A7%E4%BB%B7%E6%AF%94%E5%BA%94%E7%94%A8%E5%A4%84%E7%9A%84%E7%90%86%E5%99%A8%E7%B3%BB%E5%88%97%EF%BC%8C%E9%87%87%E7%94%A8%E5%8D%95%E4%B8%AAArm%20Cortex-A7%E5%86%85%E6%A0%B8%EF%BC%8C%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E9%AB%98%E8%BE%BE528,MHz%E3%80%82%20i.MX%206ULL%E5%BA%94%E7%94%A8%E5%A4%84%E7%90%86%E5%99%A8%E5%8C%85%E6%8B%AC%E4%B8%80%E4%B8%AA%E9%9B%86%E6%88%90%E7%9A%84%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%EF%BC%8C%E9%99%8D%E4%BD%8E%E4%BA%86%E5%A4%96%E6%8E%A5%E7%94%B5%E6%BA%90%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7%EF%BC%8C%E5%B9%B6%E7%AE%80%E5%8C%96%E4%BA%86%E4%B8%8A%E7%94%B5%E6%97%B6%E5%BA%8F%E3%80%82

## 概念区分
ARMv7属于内核版本号，而Cortex-A7则为Soc的称号，i.MX 6ULL属于 芯片型号。
Cortex-A系列用于应用处理器Application processor：主要用于手机平板等高性能计算场景。例如骁龙865采用基于Cortex-A77（大小核）魔改后的Kryo，麒麟9000也基于Cortex-A77和Cortex-A55（大小核），ARMA7就是cortex-A系列下的cortexA7。
ARMv4、ARMv5、ARMv6、ARMv7: ARM指令集架构，指令集是处理器能够识别并执行的指令集合，每一个指令可处理一个操作，并对应了一条或几条汇编指令。ARM是基于精简指令集RISC的，指令格式和长度固定，且大多数指令可在一个周期内执行完。

## eMMC是将Nand Flash和Flash Controller和eMMC接口等封装在一起的小型的存储系统，这样做的好处是：
1.简化系统存储设计，降低开发复杂度。生产Nand Flash的厂商众多，有samsung、hynix、micron等许多厂商，每家生产的产品的技术特性都稍有差异，需要针对这些特性做兼容开发，开发非常复杂；而eMMC则规定了统一的协议接口，我们只需要根据协议做开发，就能兼容各个厂商的eMMC产品，开发过程大大简化。
2.更新速度快。随着Nand Flash制程工艺的不断升级，主控的Flash Controller和FTL也需要不停的更新，才能支持新的Nand Flash。而eMMC将Flash Controller和Nand Flash封装在了一起，屏蔽了由于Nand Flash制程工艺而带来的差异，主控的controller和driver不需要做过多修改就能支持。
3.读写性能更好。eMMC在Nand Flash的基础上，加入了Cache、Memory array等技术，大大提高了读写速度。

# busybox启动流程简单解析：从init到shell login
https://www.cnblogs.com/arnoldlu/p/10868354.html


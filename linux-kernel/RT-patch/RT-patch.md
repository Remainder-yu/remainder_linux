## 问题
问题1. 实时和非实时区别是什么？
问题2：实时补丁解决了什么问题？
问题3：实时补丁做了哪些修改？
问题4：实时补丁对系统的影响分析？
问题5：什么是优先级反转？设么是优先级继承？
## 概述
Linux作为通用OS，目的构建一个完整、稳定的开源OS，尽量做到各方面整体性能平衡，而不是针对实时性场景开发。
吞吐量：在单位时间内系统能够处理的事件总数。
### 实时与非实时区别
实时与非实时主要区别在任务运行时间的确定性，以中断处理场景理解：一个硬件事件产生并以中断形式通知到CPU，中断处理函数执行->唤醒用户态对应任务，用户态任务得到执行时开始处理该中断事件。
实时性可以理解为：硬件触发的中断事件产生到对应用户态任务开始处理该事件的延迟。
实时性包括：内核可抢占、进程调度方式、中断处理机制、时钟颗粒等多个方案影响。
RT补丁修改主要涉及：中断、中断线程化、自旋锁、读写锁、顺序锁可抢占，RT-mutex优先级继承、高精度时钟、驱动模块、文件系统涉及的锁的修改。
## 修改方案实现及原理
### 硬中断线程化
在Linux中，中断具有最高优先级。在任何时刻，响应中断并执行中断处理函数，等到所有挂起的中断和软中断处理完成后才能执行正常任务，因此有可能造成实时任务得不到及时的处理。中断线程化后，中断将成为内核线程运行，而且赋予不同的实时优先级，实时任务可以比中断更高的优先级。
--> 具有最高优先级的实时任务就能得到优先处理，即使在严重负载下仍有实时性保证。

### 软中断线程化
标准Linux内核，软中断特点如下：
1. 中断上下文中，在中断处理程序执行完毕后，会执行中断下半部软中断处理，此时对软中断的执行次数最进行限制
2. 在上一个点没有处理完成的软中断，会在软中断线程中继续进行处理
3. 内核的其他地方会调用raise_softirq尝试唤醒守护线程，来执行软中断
RT-补丁修改：
1. 将处理的软中断线程扩展为每个软中断一个软中断处理线程，软中断线程定义成优先级最低的实时任务。
2. 软中断线程化的初始化流程改造：首先通过spawn_ksoftirqd()中的register_cpu_notifier(&cpu_nfb)将软中断线程进行注册，当启动cpu的时候会在raw_notifier_call_chain()中遍历所有回调函数链表，并创建属于该cpu的软中断线程。
### spinlock可抢占
在标准内核中，spin_lock自旋锁的操作是不可被抢占的，其基本流程如下：
1、关抢占；
2、获取spin_lock，获取不到就死循环获取，直到获取到为止；
3、释放锁时，打开抢占；
从上面可以看出，从1到3这段时间都是关抢占的，这当然会对系统实时响应能力有一定影响；
### Mutex锁优先级继承
主要解决：优先级反转问题。
实现优先级继承，rt_mutex关键记录：1. 锁的当前持有者；2. 所有等待该所的任务队列waiters。
优先级继承：提升持有锁的优先级与等待队列最高优先级任务一致，然后避免低优先级的任务抢占，持有锁；这样就能保证高优先级的任务可以先持有锁；

### 抢占式内核
### 内核配置
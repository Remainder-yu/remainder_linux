[学习视频arm中断](https://www.bilibili.com/video/BV1Qt4y1M7xs/?spm_id_from=333.337.search-card.all.click&vd_source=238ae623fc8447b840a509ffd36fb24e)

中断没有进程上下文，而所有的进程调度都是以进程为基础的。如果睡眠之后，进程调度器没法来唤醒它。

仔细想想，这个答案其实不然。

在没有实现或配置内核栈中断栈分离的时候，中断发生时会借用当前被中断进程的kernel stack，所以实际上中断时借宿在这个进程上，这个时候中断睡眠完全可以的或者说时可以实现的。中断上下文会保存在这个进程的stack上，等到这个进程被唤醒时，会从中断ISR中继续执行。

如果内核栈和中断栈分离，那么两者是无关的。中断中没有进程上下文，那么如果进行睡眠，内核也并不是无法继续处理，依旧可以选择一个合适的进程（比如说被中断的进程）过来，然后等中断睡眠睡醒，再继续处理中断，理论上也是可以的。

## Distributor

负责各个子中断使能，设置触发方式，优先级排序，分发到哪个CPU上。
可以管理若干个中断源，这些中断源用ID来表示，我们称之Interrupt ID

## CPU interface
使能或禁能中断事件
应答中断
通知中断处理完毕
设定优先级掩码
设定中断抢占的策略
在多个中断事件同时到来时，选择一个优先级最高的中断并通知CPU

## 中断状态维护

4个状态切换。

Inactive
中断未触发的状态

Pending
由于外设硬件产生了中断事件（或者软件触发），该中断事件已经通过硬件信号通知GIC，等待GIC分配的哪个CPU处理


Active

Active and pending


韦东山
软件中断数组：

软件中断下半部，处理的时候，可以处理所有中断的下半部。

使用软件中断处理下半部，可以被中断上半部打断。

中断下半部，也会存在耗时过长，所以将中断下半部，用线程来处理。

内核会创建好worker线程，work_queue，则放入架构提work，包括处理函数。构造一个work，填充函数，中断上半部处理，把work放入work_queue。内核线程就知道需要处理的任务。

内核线程与应用程序就可以同台竞技，而不存在软中断下半部一直不执行。

最新技术：内核线程化处理软中断。
如果使用工作队列，存在如果work_queue中，则存在某个CPU执行。
则运行100个内核线程，任何CPU都不会工作太久。



# 主要数据结构

硬件中断号是属于某个域的。


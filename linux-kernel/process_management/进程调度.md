
# 1. Linux进程调度
## 1.1. CFS调度器的设计框架
备注：linux将线程和进程视为一个，进程调度也包含了线程调度功能；

### 1.1.1. 从设计层面总结进程调度一些设计思想
把进程抽象成进程描述符task_struct:包含进程所需的数据，如状态信息、调度信息、优先级信息，内存页信息等；
把需要调度的东西抽象成调度实体sched_entity：调度实体是进程、进程组、用户等。这里包含负载权重值、对应红黑树节点、虚拟运行时vruntime等；
把调度策略（算法）抽象成调度类sched_class：包含一组通用的调度操作接口，将接口和实现分离。你可以根据这组接口实现不同的调度算法，使得一个linux调度程序可以有多个不同的调度策略；
把调度的组织抽象成可运行队列rq：包含自旋锁、进程数量、用于公平调度的CFS信息结构、当前运行的进程描述符等；时机进程队列用红黑树来维护；
把CFS调度的运行队列信息抽象成cfs_rq:包含红黑树的根结点、正在运行的进程指针、用于负载平衡的叶子队列等；


# 2. 调度进程
schedule() 是 Linux 内核的调度器入口，它原子地完成进程切换，确保系统公平、高效地运行任务。
调度进程的核心函数：
```cpp
/**
 * asmlinkage: 告诉编译器，这个参数通过栈传递，而不是寄存器
 * __visible: 防止编译器将其优化为静态内联，确保它能被外部模块引用
 * __sched：一个编译器属性，表示这个函数与调度有关，用于栈回溯
*/
asmlinkage __visible void __sched schedule(void)
{
	struct task_struct *tsk = current;

	sched_submit_work(tsk);  // 提交工作，防止死锁，在调度前，把当前任务可能挂起的IO工作刷掉（如异步IO、writeback）
	do {
		preempt_disable(); // 关闭内核抢占，防止调度过程中被其他高优先级任务打断，确保调度器的原子性
		__schedule(SM_NONE);
		sched_preempt_enable_no_resched();  // 重新开启内核抢占，但不触发重新调度
	} while (need_resched());  // 检查其他任务标志位是否需要调度
	sched_update_worker(tsk);
}
EXPORT_SYMBOL(schedule);

```

分析各个函数的主要作用：

| 阶段                      | 作用                 |
| ----------------------- | ------------------ |
| `sched_submit_work()`   | 防止调度前挂起 IO，避免死锁    |
| `preempt_disable()`     | 保证调度过程不被打断         |
| `__schedule()`          | **真正切换进程**         |
| `need_resched()`        | 确保调度公平性，**让出 CPU** |
| `sched_update_worker()` | 优化 kworker 的唤醒路径   |


`__schedule`主要处理过程:
1. 调用pick_next_task以选择下一个进程；
2. 调用context_switch以切换进程；

### 2.0.1. 选择下一个进程

```cpp
static void __sched notrace __schedule(unsigned int sched_mode)
-> next = pick_next_task(rq, prev, &rf);

static struct task_struct *
pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	return __pick_next_task(rq, prev, rf);
}

```

### 2.0.2. 进程上下文切换



## 2.1. 调度时机


## 2.2. Linux进程调度：实时调度

实时调度算法：
Linux提供了两种实时调度策略：SCHED_FIFO和SCHED，其中RR就是带有时间片的FIFO。
这两种调度算法实现都是基于静态优先级，内核不为实时进程计算动态优先级。这样可以保证给定优先级的实时进程总能抢占优先级比他低的进程。


## 2.3. 参考文献

1. [Linux进程调度](https://www.cnblogs.com/LoyenWang/p/12584345.html)
2. [Linux调度基础](https://www.cnblogs.com/LoyenWang/p/12249106.html)
3. [linux进程调度（1）CFS调度的设计框架](https://blog.csdn.net/zhoudaxia/article/details/7375668)
4. [CFS调度操作](https://blog.csdn.net/zhoudaxia/article/details/7375780?spm=1001.2101.3001.10796)
